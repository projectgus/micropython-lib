# MicroPython LoRa STM32WL55 embedded sub-ghz radio driver
# MIT license; Copyright (c) 2022 Angus Gratton
#
# This driver is essentially an embedded SX1262 with a custom internal interface block.
# Requires the machine.SubGHzRadio() support in MicroPython to access.
#
# LoRa is a registered trademark or service mark of Semtech Corporation or its affiliates.
import machine
from . import sx126x
from micropython import const

_CMD_CLR_ERRORS = const(0x07)


# Default antenna switch config is as per Nucleo WL-55 board. See UM2592 Fig 18.
# Possible to work with other antenna switch board configurations by passing
# different ant_sw_class arguments to the modem, any class that creates an object with rx/tx


class NucleoWL55RFConfig:
    def __init__(self):
        self._FE_CTRL = (machine.Pin(x, mode=machine.Pin.OUT) for x in ("C4", "C5", "C3"))

    def _set_fe_ctrl(self, values):
        for pin, val in zip(self._FE_CTRL, values):
            pin(val)

    def rx(self):
        self._set_fe_ctrl((0, 1, 0))

    def tx(self, hp):
        self._set_fe_ctrl((0 if hp else 1, 1, 1))

    def idle(self):
        pass


class _WL55SubGhzModem(sx126x._SX1262):
    # Don't construct this directly, construct lora.WL55SubGhzModem or lora.AsyncWL55SubGHzModem
    def __init__(
        self,
        lora_cfg=None,
        external_hse32=True,
        tcxo_millivolts=1600,
        ant_sw=NucleoWL55RFConfig,
    ):
        self._r = machine.SubGHzRadio(external_hse32)

        if ant_sw == NucleoWL55RFConfig:
            # To avoid the default argument being an object instance
            ant_sw = NucleoWL55RFConfig()

        super().__init__(
            self._r.spi(),
            self._r.cs,
            self._r.is_busy,
            self._r,  # dio1
            dio2_rf_sw=False,
            dio3_tcxo_millivolts=tcxo_millivolts,
            lora_cfg=lora_cfg,
            ant_sw=ant_sw,
        )

    def _clear_errors(self):
        # A weird difference between STM32WL55 and SX1262, WL55 only takes one
        # parameter byte for the Clr_Error() command compared to two on SX1262.
        # The bytes are always zero in both cases.
        #
        # (Not clear if sending two bytes will also work always/sometimes, but
        # sending one byte to SX1262 definitely does not work!
        self._cmd("BB", _CMD_CLR_ERRORS, 0x00)

    def _clear_irq(self, clear_bits=0xFFFF):
        super()._clear_irq(clear_bits)
        # SubGHZ Radio Hardware IRQ requires manual re-enabling after interrupt
        # flags cleared
        self._r.irq_en(True)


# Define the actual modem classes that use the SyncModem & AsyncModem "mixin-like" classes
# to create sync and async variants.

try:
    from .sync_modem import SyncModem

    class WL55SubGhzModem(_WL55SubGhzModem, SyncModem):
        pass

except ImportError:
    pass

try:
    from .async_modem import AsyncModem

    class AsyncWL55SubGhzModem(_WL55SubGhzModem, AsyncModem):
        pass

except ImportError:
    pass


__version__ = '0.1'

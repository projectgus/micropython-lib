# MicroPython USB device module
# MIT license; Copyright (c) 2022 Angus Gratton
from micropython import const
import machine
import struct
from io import BytesIO

from .utils import split_bmRequestType, EP_IN_FLAG, Descriptor

# USB descriptor types
_STD_DESC_DEVICE_TYPE = const(0x1)
_STD_DESC_CONFIG_TYPE = const(0x2)
_STD_DESC_STRING_TYPE = const(0x3)
_STD_DESC_INTERFACE_TYPE = const(0x4)
_STD_DESC_ENDPOINT_TYPE = const(0x5)
_STD_DESC_INTERFACE_ASSOC = const(0xB)

# Standard USB descriptor lengths
_STD_DESC_CONFIG_LEN = const(9)
_STD_DESC_INTERFACE_LEN = const(9)

# Standard control request bmRequest fields, can extract by calling split_bmRequestType()
_REQ_RECIPIENT_DEVICE = const(0x0)
_REQ_RECIPIENT_INTERFACE = const(0x1)
_REQ_RECIPIENT_ENDPOINT = const(0x2)
_REQ_RECIPIENT_OTHER = const(0x3)

# Offsets into the standard configuration descriptor, to fixup
_OFFS_CONFIG_iConfiguration = const(6)

# Singleton _USBDevice instance
_inst = None

_NUM_DEVICE_STRS = const(4)


def get_usbdevice():
    # Access the singleton instance of the MicroPython _USBDevice object.
    #
    # TODO: It might be better to factor this as a module-level interface?
    global _inst
    if not _inst:
        _inst = _USBDevice()
    return _inst


class _USBDevice:
    # Class that implements the Python parts of the MicroPython USBDevice.
    #
    # This object represents any interfaces on the USB device that are implemented
    # in Python, and also allows disabling the 'static' USB interfaces that are
    # implemented in Python (if include_static property is set to False).
    #
    # Should be accessed via the singleton getter module function get_usbdevice(),
    # not instantiated directly..
    def __init__(self):
        self._eps = {}  # Mapping from endpoint address to interface object
        self._ep_cbs = {}  # Mapping from endpoint address to Optional[xfer callback]
        self._itfs = (
            []
        )  # List of USBInterfaces (NOTE: each of these may contain >1 USB Interface descriptor)
        self._desc = Descriptor()
        self.include_static = True  # Include static devices when enumerating?

        # Device properties, set non-NULL to override static values
        self.manufacturer_str = None
        self.product_str = None
        self.serial_str = None
        self.id_vendor = None
        self.id_product = None
        self.device_class = None
        self.device_subclass = None
        self.device_protocol = None
        self.bcd_device = None

        # Configuration properties
        self.config_str = None
        self.max_power_ma = 50

        usbd = self._usbd = machine.USBD()
        usbd.init(
            descriptor_device_cb=self._descriptor_device_cb,
            descriptor_config_cb=self._descriptor_config_cb,
            descriptor_string_cb=self._descriptor_string_cb,
            open_cb=self._open_cb,
            reset_cb=self._reset_cb,
            control_xfer_cb=self._control_xfer_cb,
            xfer_cb=self._xfer_cb,
        )

    def add_interface(self, itf):
        # Add an instance of USBInterface to the USBDevice.
        #
        # The next time USB is reenumerated (by calling .reenumerate() or
        # otherwise), this interface will appear to the host.
        self._itfs.append(itf)

    def remove_interface(self, itf):
        # Remove an instance of USBInterface from the USBDevice.
        #
        # If the USB device is currently enumerated to a host, and in particular
        # if any endpoint transfers are pending, then this may cause it to
        # misbehave as these transfers are not cancelled.
        self._itfs.remove(itf)

    def reenumerate(self):
        # Disconnect the USB device and then reconnect it, causing the host to
        # reenumerate it.
        #
        # Any open USB interfaces (for example USB-CDC serial connection) will be
        # temporarily terminated.
        #
        # This is the only way to change the composition of an existing USB device
        # from the device side without disconnecting/reconnecting the port.
        self._usbd.reenumerate()

    def _descriptor_device_cb(self):
        # Singleton callback from TinyUSB to read the USB device descriptor.
        #
        # This function will build a new device descriptor based on the 'static'
        # USB device values compiled into MicroPython, but many values can be
        # optionally overriden by setting properties of this object.

        FMT = "<BBHBBBBHHHBBBB"
        # static descriptor fields
        f = struct.unpack(FMT, self._usbd.static.desc_device)

        def maybe_set(value, idx):
            # Override a numeric descriptor value or keep static value f[idx] if 'value' is None
            if value is not None:
                return value
            return f[idx]

        d = self._desc
        d.reset()
        # Either copy each descriptor field directly from the static device descriptor, or 'maybe'
        # override if a custom value has been set on this object
        d.pack(
            FMT,
            f[0],  # bLength
            f[1],  # bDescriptorType
            f[2],  # bcdUSB
            maybe_set(self.device_class, 3),  # bDeviceClass
            maybe_set(self.device_subclass, 4),  # bDeviceSubClass
            maybe_set(self.device_protocol, 5),  # bDeviceProtocol
            f[6],  # bMaxPacketSize0, TODO: allow overriding this value?
            maybe_set(self.id_vendor, 7),  # idVendor
            maybe_set(self.id_product, 8),  # idProduct
            maybe_set(self.bcd_device, 9),  # bcdDevice
            self._get_str_index(self.manufacturer_str) or f[10],  # iManufacturer
            self._get_str_index(self.product_str) or f[11],  # iProduct
            self._get_str_index(self.serial_str) or f[12],  # iSerialNumber
            f[13],  # bNumConfigurations
        )
        return d.b

    def _get_interface(self, index):
        # Return a reference to the interface object with the given USB index.
        index -= self._usbd.static.itf_max
        assert index >= 0  # index shouldn't be in the static range
        for itf in self._itfs:
            n = itf.num_itfs()
            if index < n:
                return itf
            index -= n
        return None  # host has old mappings for interfaces

    def _descriptor_config_cb(self):
        # Singleton callback from TinyUSB to read the configuration descriptor.
        #
        # Each time this function is called (in response to a GET DESCRIPTOR -
        # CONFIGURATION request from the host), it rebuilds the full configuration
        # descriptor in the shared _desc buffer.
        #
        # This normally only happens during enumeration, but may happen more than
        # once (the host will first ask for a minimum length descriptor, and then
        # use the length field request to request the whole thing).
        #
        # Note: Currently only one configuration per device is supported.

        static = self._usbd.static

        d = self._desc
        if self.include_static:
            # don't reset _desc here, just re-assign the static descriptor at the start
            d.b[0 : len(static.desc_cfg)] = static.desc_cfg
            d._l = len(static.desc_cfg)
        else:
            # the configuration descriptor space at the start will be filled in
            # before we return, so just advance the length past this now.
            self._l = _STD_DESC_CONFIG_LEN

        self._eps = {}  # rebuild endpoint mapping as we enumerate each interface
        self._ep_cbs = {}
        itf_num = static.itf_max
        ep_num = max(static.ep_max, 1)  # Endpoint 0 always reserved for control

        for itf in self._itfs:
            offs = d._l

            itf.descriptor_config_cb(d, itf_num, ep_num)
            itf_num += itf.num_itfs()

            # Scan the new descriptor data for endpoint descriptors
            while offs < d._l:
                dl = d.b[offs]  # Length
                dt = d.b[offs + 1]  # Type
                if dt == _STD_DESC_ENDPOINT_TYPE:
                    ep_addr = d.b[offs + 2]
                    self._eps[ep_addr] = itf
                    self._ep_cbs[ep_addr] = None  # no pending callback

                    # Find the next ep_num that can be used for next interface
                    # (Note this does skip some potential EPs, as each ep_num can be both IN and OUT)
                    ep_num = max((ep_addr & ~EP_IN_FLAG) + 1, ep_num)
                offs += dl

        # Go back and update the Standard Configuration Descriptor
        # header at the start with values based on the complete
        # descriptor.
        #
        # See USB 2.0 specification section 9.6.3 p264 for details.

        bmAttributes = (
            (1 << 7)  # Reserved
            | (0 if self.max_power_ma else (1 << 6))  # Self-Powered
            # Remote Wakeup not currently supported
        )

        iConfiguration = self._get_str_index(self.config_str)
        if self.include_static and not iConfiguration:
            iConfiguration = self._desc.b[_OFFS_CONFIG_iConfiguration]

        bNumInterfaces = self._usbd.static.itf_max if self.include_static else 0
        bNumInterfaces += len(self._itfs)

        d.pack_into(
            "<BBHBBBBB",
            0,
            _STD_DESC_CONFIG_LEN,  # bLength
            _STD_DESC_CONFIG_TYPE,  # bDescriptorType
            d._l,  # wTotalLength
            bNumInterfaces,
            1,  # bConfigurationValue
            iConfiguration,
            bmAttributes,
            self.max_power_ma,
        )

        return d.b

    def _descriptor_string_cb(self, idx):
        # Singleton callback from TinyUSB to get a string descriptor. Returns the
        # string itself.
        #
        # Work through the possible dynamic string values and return the
        # corresponding string.
        #
        # This is a little slow, but rarely called and avoids having to allocate
        # a list of all strings.
        #
        # _get_str_index() is the inverse of this function.
        #
        idx -= self._usbd.static.str_max
        assert (
            idx >= 0
        )  # Shouldn't get any calls here where idx is less than first dynamic string index

        # Work through the possible dynamic device strings
        # (without allocating a list).
        if idx == 0:
            return self.manufacturer_str
        if idx == 1:
            return self.product_str
        if idx == 2:
            return self.serial_str
        if idx == 3:
            return self.config_str

        idx -= _NUM_DEVICE_STRS

        # Now work through each interface
        for itf in self._itfs:
            try:
                return itf.strs[idx]
            except IndexError:
                idx -= len(itf.strs)

        return None

    def _get_str_index(self, s):
        # Return the USB descriptor index for a string 's' defined at runtime,
        # or 0 if 's' is None
        #
        # Inverse of _descriptor_string_cb().
        #
        # If set, 's' must be a string that the caller knows is either a "device
        # string", or is included in the 'strs' field of one the USBInterface
        # instances added to the device. Will raise ValueError otherwise.
        if not s:
            return 0

        idx = self._usbd.static.str_max

        # Work through the possible dynamic device strings
        # (without allocating a list.)
        if s == self.manufacturer_str:
            return idx
        if s == self.product_str:
            return idx + 1
        if s == self.serial_str:
            return idx + 2
        if s == self.config_str:
            return idx + 3

        idx += _NUM_DEVICE_STRS

        # Now work through each interface
        for i in self._itfs:
            try:
                return idx + i.strs.index(s)
            except ValueError:
                idx += len(i.strs)

        raise ValueError(s)

    def _open_cb(self, interface_desc_view):
        # Singleton callback from TinyUSB custom class driver, when USB host does
        # Set Configuration. The "runtime class device" accepts all interfaces that
        # it has sent in descriptors, and calls this callback.

        # Currently this just calls handle_open() on all interfaces, as there is only
        # one configuration so we assume they are all opened together.
        for itf in self._itfs:
            itf.handle_open()

    def _reset_cb(self):
        # Callback when the USB device is reset by the host

        # Cancel outstanding transfer callbacks
        for k in self._ep_cbs.keys():
            self._ep_cbs[k] = None

        # Allow interfaces to respond to the reset
        for itf in self._itfs:
            itf.handle_reset()

    def _submit_xfer(self, ep_addr, data, done_cb=None):
        # Singleton function to submit a USB transfer (of any type except control).
        #
        # Generally, drivers should call USBInterface.submit_xfer() instead. See
        # that function for documentation about the possible parameter values.
        if self._ep_cbs[ep_addr]:
            raise RuntimeError("xfer_pending")

        # USBD callback may be called immediately, before Python execution
        # continues, so set it first.
        #
        # To allow xfer_pending checks to work, store True instead of None.
        self._ep_cbs[ep_addr] = done_cb or True
        self._usbd.submit_xfer(ep_addr, data)

    def _xfer_cb(self, ep_addr, result, xferred_bytes):
        # Singleton callback from TinyUSB custom class driver when a transfer completes.
        cb = self._ep_cbs.get(ep_addr, None)
        self._ep_cbs[ep_addr] = None
        if callable(cb):
            cb(ep_addr, result, xferred_bytes)

    def _control_xfer_cb(self, stage, request):
        # Singleton callback from TinyUSB custom class driver when a control
        # transfer is in progress.
        #
        # stage determines appropriate responses (possible values
        # utils.STAGE_SETUP, utils.STAGE_DATA, utils.STAGE_ACK).
        #
        # The TinyUSB class driver framework only calls this function for
        # particular types of control transfer, other standard control transfers
        # are handled by TinyUSB itself.
        wIndex = request[4] + (request[5] << 8)
        recipient, _, _ = split_bmRequestType(request[0])

        itf = None
        result = None

        if recipient == _REQ_RECIPIENT_DEVICE:
            itf = self._get_interface(wIndex & 0xFFFF)
            if itf:
                result = itf.handle_device_control_xfer(stage, request)
        elif recipient == _REQ_RECIPIENT_INTERFACE:
            itf = self._get_interface(wIndex & 0xFFFF)
            if itf:
                result = itf.handle_interface_control_xfer(stage, request)
        elif recipient == _REQ_RECIPIENT_ENDPOINT:
            ep_num = wIndex & 0xFFFF
            itf = self._eps.get(ep_num, None)
            if itf:
                result = itf.handle_endpoint_control_xfer(stage, request)

        if not itf:
            # At time this code was written, only the control transfers shown
            # above are passed to the class driver callback. See
            # invoke_class_control() in tinyusb usbd.c
            print(f"Unexpected control request type {request[0]:#x}")
            return False

        # Expecting any of the following possible replies from
        # handle_NNN_control_xfer():
        #
        # True - Continue transfer, no data
        # False - STALL transfer
        # Object with buffer interface - submit this data for the control transfer
        return result


class USBInterface:
    # Abstract base class to implement USB Interface (and associated endpoints),
    # or a collection of USB Interfaces, in Python
    #
    # (Despite the name an object of type USBInterface can represent multiple
    # associated interfaces, with or without an Interface Association Descriptor
    # prepended to them. Override num_itfs() if assigning >1 USB interface.)

    def __init__(self, strs=[]):
        # Parameters:
        #
        # - strs - Set to any strings referenced in descriptors. Entries can be updated
        #   at runtime via the 'strs' field, however the length of the list should
        #   always be the same.
        self._open = False
        self.strs = strs

    def descriptor_config_cb(self, desc, itf_num, ep_num):
        # Callback to build the configuration descriptor contents for
        # this interface or group of interfaces.
        #
        # This should add:
        #
        # - At least one standard Interface descriptor (can call
        # - desc.interface()).
        #
        # Plus, optionally:
        #
        # - One or more endpoint descriptors (can call desc.endpoint()).
        # - An Interface Association Descriptor, prepended before.
        # - Other class-specific configuration descriptor data.
        #
        # Parameters:
        #
        # - desc - utils.Descriptor instance that holds the (reused) Descriptor
        #   buffer for the USB device.
        #
        # - itf_num - First number of this interface.
        #
        # - ep_num - Address of the first available endpoint number to use
        #   for endpoint descriptor addresses. Subclasses should save the
        #   endpoint addresses selected, to look up later.
        #
        # If setting any string indexes, call _get_str_index() to find the
        # correct value to use.
        raise NotImplementedError

    def num_itfs(self):
        # Return the number of actual USB Interfaces represented by this object.
        #
        # Only needs to be overriden if implementing a USBInterface class that
        # represents more than one USB Interface descriptor (i.e. MIDI).
        return 1

    def _get_str_index(self, s):
        # Wrapper function to return the index of a string 's' in the USB device.
        #
        # Call this function if including the index of a string in a descriptor.
        # The string itself must be found in the list self.strs.
        return _inst._get_str_index(s)

    def handle_open(self):
        # Callback called when the USB host accepts the device configuration.
        #
        # Override this function to initiate any operations that the USB interface
        # should do when the USB device is configured to the host.
        self._open = True

    def handle_reset(self):
        # Callback called on every registered interface when the USB device is
        # reset by the host. This can happen when the USB device is unplugged,
        # or if the host triggers a reset for some other reason.
        #
        # Override this function to cancel any pending operations specific to
        # the interface (outstanding USB transfers are already cancelled).
        #
        # At this point, no USB functionality is available - handle_open() will
        # be called later if/when the USB host re-enumerates and configures the
        # interface.
        self._open = False

    def is_open(self):
        # Returns True if the interface is in use
        return self._open

    def handle_device_control_xfer(self, stage, request):
        # Control transfer callback. Override to handle a non-standard device
        # control transfer where bmRequestType Recipient is Device, Type is
        # utils.REQ_TYPE_CLASS, and the lower byte of wIndex indicates this interface.
        #
        # (See USB 2.0 specification 9.4 Standard Device Requests, p250).
        #
        # This particular request type seems pretty uncommon for a device class
        # driver to need to handle, most hosts will not send this so most
        # implementations won't need to override it.
        #
        # Parameters:
        #
        # - stage is one of utils.STAGE_SETUP, utils.STAGE_DATA, utils.STAGE_ACK.
        #
        # - request is a memoryview into a USB request packet, as per USB 2.0
        #   specification 9.3 USB Device Requests, p250.  the memoryview is only
        #   valid while the callback is running.
        #
        # The function can call split_bmRequestType(request[0]) to split
        # bmRequestType into (Recipient, Type, Direction).
        #
        # Result, any of:
        #
        # - True to continue the request, False to STALL the endpoint.
        # - Buffer interface object to provide a buffer to the host as part of the
        #   transfer, if applicable.
        return False

    def handle_interface_control_xfer(self, stage, request):
        # Control transfer callback. Override to handle a device control
        # transfer where bmRequestType Recipient is Interface, and the lower byte
        # of wIndex indicates this interface.
        #
        # (See USB 2.0 specification 9.4 Standard Device Requests, p250).
        #
        # bmRequestType Type field may have different values. It's not necessary
        # to handle the mandatory Standard requests (bmRequestType Type ==
        # utils.REQ_TYPE_STANDARD), if the driver returns False in these cases then
        # TinyUSB will provide the necessary responses.
        #
        # See handle_device_control_xfer() for a description of the arguments and
        # possible return values.
        return False

    def handle_endpoint_control_xfer(self, stage, request):
        # Control transfer callback. Override to handle a device
        # control transfer where bmRequestType Recipient is Endpoint and
        # the lower byte of wIndex indicates an endpoint address associated
        # with this interface.
        #
        # bmRequestType Type will generally have any value except
        # utils.REQ_TYPE_STANDARD, as Standard endpoint requests are handled by
        # TinyUSB. The exception is the the Standard "Set Feature" request. This
        # is handled by Tiny USB but also passed through to the driver in case it
        # needs to change any internal state, but most drivers can ignore and
        # return False in this case.
        #
        # (See USB 2.0 specification 9.4 Standard Device Requests, p250).
        #
        # See handle_device_control_xfer() for a description of the parameters and
        # possible return values.
        return False

    def xfer_pending(self, ep_addr):
        # Return True if a transfer is already pending on ep_addr.
        #
        # Only one transfer can be submitted at a time.
        return bool(_inst._ep_cbs[ep_addr])

    def submit_xfer(self, ep_addr, data, done_cb=None):
        # Submit a USB transfer (of any type except control)
        #
        # Parameters:
        #
        # - ep_addr. Address of the endpoint to submit the transfer on. Caller is
        #   responsible for ensuring that ep_addr is correct and belongs to this
        #   interface. Only one transfer can be active at a time on each endpoint.
        #
        # - data. Buffer containing data to send, or for data to be read into
        #   (depending on endpoint direction).
        #
        # - done_cb. Optional callback function for when the transfer
        # completes. The callback is called with arguments (ep_addr, result,
        # xferred_bytes) where result is one of xfer_result_t enum (see top of
        # this file), and xferred_bytes is an integer.
        #
        # If the function returns, the transfer is queued.
        #
        # The function will raise RuntimeError under the following conditions:
        #
        # - The interface is not "open" (i.e. has not been enumerated and configured
        #   by the host yet.)
        #
        # - A transfer is already pending on this endpoint (use xfer_pending() to check
        #   before sending if needed.)
        #
        # - A DCD error occurred when queueing the transfer on the hardware.
        #
        #
        # Will raise TypeError if 'data' isn't he correct type of buffer for the
        # endpoint transfer direction.
        #
        # Note that done_cb may be called immediately, possibly before this
        # function has returned to the caller.
        if not self._open:
            raise RuntimeError("Not open")
        _inst._submit_xfer(ep_addr, data, done_cb)

    def stall(self, ep_addr, *args):
        # Set or get the endpoint STALL state.
        #
        # To get endpoint stall stage, call with a single argument.
        # To set endpoint stall state, call with an additional boolean
        # argument to set or clear.
        #
        # Generally endpoint STALL is handled automatically, but there are some
        # device classes that need to explicitly stall or unstall an endpoint
        # under certain conditions.
        if not self._open or ep_addr not in _inst._eps:
            raise RuntimeError
        _inst._usbd.stall(ep_addr, *args)


__version__ = '0.1.0'
